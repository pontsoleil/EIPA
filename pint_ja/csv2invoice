#!/usr/bin/env python3
#coding: utf-8
#
# generate Open Peoopl e-Invoice (UBL 2.1) fron CSV file
# 
# designed by SAMBUICHI, Nobuyuki (Sambuichi Professional Engineers Office)
# written by SAMBUICHI, Nobuyuki (Sambuichi Professional Engineers Office)
#
# MIT License
# 
# Copyright (c) 2021 SAMBUICHI Nobuyuki (Sambuichi Professional Engineers Office)
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
import xml.etree.ElementTree as ET
from collections import defaultdict
import csv
import re
import json
import sys 
import os
import argparse

from dic2etree import * 

pintDict = {}
header_id = None
header_count = 0
DocumentCurrencyCode = None
TaxCurrencyCode = None

def clean_list(Dic):
  for k, v in Dic.items():
    if isinstance(v, dict):
      clean_list(v)
    elif isinstance(v, list):
      index = 0
      for l in v:
        if l == {}:
          index += 1
        elif isinstance(l, dict):
          clean_list(l)
      if index > 0:
        for i in range(index):
          v.pop(0) 

def file_path(pathname):
  if '/' == pathname[0:1]:
    return pathname
  else:
    dir = os.path.dirname(__file__)
    new_path = os.path.join(dir, pathname)
    return new_path

# ref https://stackoverflow.com/questions/15210148/get-parents-keys-from-nested-dictionary
# breadcrumb(json_dict_or_list, value)
def get_path_value(base, path):
  key = path[0]
  if isinstance(base, dict):
    if 1 == len(path):
      if key in base.keys():
        return {'k':key, 'v':base[key]}
    else:
      path.pop(0)
      for k, v in base.items():
        if isinstance(base, dict):
          if key == k:
            p = get_path_value(v, path)
            return p
  elif isinstance(base, list):
    try:
      key = int(key)
      if key < len(base):
        path.pop(0)
        p = get_path_value(base[key], path)
        return p
    except ValueError:
      pass

def set_path_value(base, path, value, datatype):
  if isinstance(base,str):
    return None
  key = path[0]
  if len(path) > 1:
    if not base and 2==len(path) and '@'==path[1][:1]:
      base[path[0]] = {}
      base[path[0]][path[1]] = str(value)
    else:
      try:
        index = int(path[1])
        if not key in base:
          base[key] = {}
        if not isinstance(base[key], list):
          base[key] = [{}]
        else:
          pass
        if index >= len(base[key]):
          for i in range(index - len(base[key]) + 1):
            base[key].append({})
        try:
          base = base[key][index]
        except Exception:
          pass
        path.pop(0)
        path.pop(0)
        p = set_path_value(base, path, value, datatype)
        return p
      except ValueError:
        pass
  if isinstance(base, list):
    base = base[-1]
  if isinstance(base, dict):
    if 1 == len(path):
      if not key in base.keys():
        base[key] = {}
      if 'Amount' == datatype or 'Unit Price Amount' == datatype:
        value = {'#text': str(value), '@currencyID': DocumentCurrencyCode}
        base[key] = value
      elif 'Quantity' == datatype:
        base[key]['#text'] = str(value)#, '@unitCode': 'EA'}
      else:
        base[key] = value  # when Amount/Unit/Quantity is already set
      return {'k':key, 'v':base[key]}
    elif '@' == path[1][:1]:
      if not key in base.keys():
        base[key] = {}
      if isinstance(base[key], str):
        v = base[key]
        base[key] = {}
        base[key]['#text'] = v
      base[key][path[1]] = value
      return {'k':key, 'v': base[key]}
    else:
      path.pop(0)
      if key in base.keys():
        if isinstance(base, dict):
          v = base[key]
        elif isinstance(base, list):
          v = base[key][-1]
      else:
        base[key] = {}
        v = base[key]
      p = set_path_value(v, path, value, datatype)
      return p

def set_record(Dic, header, record):
  head = record[0]
  base0 = pintDict[head]
  seq0 = record[1]
  root = '/Invoice'
  if '' == base0 or '/' == base0 or 'ibg-00' == base0:
    base = root
  else:
    if 'xpath' in pintDict[head]:
      base = base0['xpath']
    else:
      return
  base_path = base[1:].split('/')
  if '' != seq0 and '/Invoice' != base:
    try:
      base_path += [int(seq0)]
    except ValueError:
      pass
  N = 1
  n = 0
  for cell in record:  # traverse field in a record
    if n > N and n < len(header) and cell:
      id = header[n]
      if id:
        data = pintDict[id]
        if data:
          xpath = data['xpath']
          datatype = data['datatype']
          if xpath:
            if '/Invoice/cac:TaxTotal/cbc:TaxAmount' in xpath:
              xpath = '/Invoice/cac:TaxTotal/cbc:TaxAmount'
            elif 'ChargeIndicator=' in xpath:
              allowanceCharge = re.sub(r'(.*)\[cbc:ChargeIndicator=(true|false)\(\)\](.*)','\\1',xpath)
              chargeIndicator = re.sub(r'.*\[cbc:ChargeIndicator=(true|false)\(\)\](.*)','\\1',xpath)
              pathList = re.sub(base, '', allowanceCharge)[1:].split('/')
              path = base_path + pathList
              path.append('cbc:ChargeIndicator')
              set_path_value(Dic, path, chargeIndicator, 'Indicator')
              xpath = re.sub(r'(.*)\[cbc:ChargeIndicator=(true|false)\(\)\](.*)','\\1\\3',xpath)
            # else:
            pathList = re.sub(base, '', xpath)[1:].split('/')
            path = base_path + pathList
            set_path_value(Dic, path, cell, datatype)
    n += 1

if __name__ == '__main__':
  # Create the parser
  parser = argparse.ArgumentParser(prog='genInvoice',
                                  usage='%(prog)s [options] infile outfile',
                                  description='CSVファイルから電子インボイスXMLを作成')
  # Add the arguments
  parser.add_argument('inFile', metavar='infile', type=str, help='入力CSVファイル')
  parser.add_argument('-o', '--out')
  parser.add_argument('-e', '--encoding')  # 'Shift_JIS' 'cp932'
  parser.add_argument('-v', '--verbose', action='store_true')
  parser.add_argument('-d', '--debug', action='store_true')

  args = parser.parse_args()
  in_file = file_path(args.inFile)
  pre, ext = os.path.splitext(in_file)
  tmp_file = pre+'.txt'
  if args.out:
    out_file = args.out.lstrip()
    out_file = file_path(out_file)
  else:
    out_file = pre+'.xml'
  encoding = args.encoding.lstrip()
  if not encoding:
    encoding = 'UTF-8'
  verbose = args.verbose
  DEBUG = args.debug

  # Check if infile exists
  if not os.path.isfile(in_file):
    print('入力ファイルがありません')
    sys.exit()
  if verbose:
    print('** START ** ', __file__)

  # # initialize globals
  Dic = defaultdict(type(''))
  Dic['Invoice'] = {}
  dictID = defaultdict(type(''))
  pintDict = defaultdict(type(''))


  pint_file = file_path('data/common/xpath.csv')
  # SemSort,BT_ID,ID,Level,BT,BT_ja,Definition,Definition_ja,Explanation,Explanation_ja,Example,
  # 0       1     2  3     4  5     6          7             8           9              10      
  # Card,DataType,Section,Extension,SyntSort,XPath,Attributes,Rules,UBL_DataType,Cardinality,Alignment
  # 11   12       13      14        15       16    17         18    19           20          21
  COL_SemanticSort = 0
  COL_ID = 2
  COL_level = 3
  COL_BT = 4
  COL_BT_ja = 5
  COL_card = 11
  COL_datatype = 12
  COL_SyntaxSort = 15
  COL_xpath = 16
  if verbose: print(f'*** XPath file {pint_file}')
  with open(pint_file, encoding='utf-8', newline='') as f0:
    reader = csv.reader(f0) #, delimiter='\t')
    header = next(reader)
    for v in reader:
      id = v[COL_ID].strip()
      if id:
        xpath = v[COL_xpath]
        syntaxSort = v[COL_SyntaxSort]
        if not syntaxSort:
          syntaxSort = '9999'
        if not xpath:
          xpath = '/'+id
        if len(v) > COL_xpath and '/' in xpath:
          if "[not(cbc:DocumentTypeCode='130')]" in xpath:
            xpath = xpath.replace("[not(cbc:DocumentTypeCode='130')]",'')
          elif "[cbc:DocumentTypeCode='130']" in xpath:
            xpath = xpath.replace("[cbc:DocumentTypeCode='130']",'')
          # semanticSort = v[COL_SemanticSort]
          if v[COL_BT]: BT = v[COL_BT]
          else: BT = None
          if v[COL_BT_ja]: BT_ja = v[COL_BT_ja]
          else: BT_ja = None
          level = v[COL_level]
          card = ''+v[COL_card].strip()
          datatype = ''+v[COL_datatype].strip()
          data = {'syntaxSort':syntaxSort,'id':id,'level':level,'BT':BT,'BT_ja':BT_ja,'card':card,'datatype':datatype,'xpath':xpath}
          pintDict[id] = data

  if verbose:
    print(f'*** Input file {in_file}')

  with open(in_file, encoding=encoding, newline='') as f:
    reader = csv.reader(f)#, delimiter='\t')
    rows = []
    i = 0
    for record in reader:
      id = record[0]
      if id:
        data = pintDict[id]
        syntaxSort = data['syntaxSort']
        if 'ibt-005'==id:
          DocumentCurrencyCode = record[4]
        elif 'ibt-006'==id:
          TaxCurrencyCode = record[4]
      else:
        syntaxSort = '000'+str(i)
        i += 1
      row = [syntaxSort,id]+record[4:]
      rows.append(row)

  # https://www.geeksforgeeks.org/ways-sort-list-dictionaries-values-python-using-itemgetter/ 
  # https://www.delftstack.com/ja/howto/python/sort-list-of-lists-in-python/
  sorted_rows = sorted(rows, key=lambda x:x[0])
  sorted_rows = [d[1:] for d in sorted_rows]

  # see https://stackoverflow.com/questions/6473679/transpose-list-of-lists
  # transposed_rows = [list(i) for i in zip(*sorted_rows)]
  rows = len(sorted_rows)
  cols = len(sorted_rows[0])
  transposed_rows = []
  while len(transposed_rows) < cols:
    transposed_rows.append([])
    while len(transposed_rows[-1]) < rows:
      transposed_rows[-1].append(0)
  for i in range(rows):
    for j in range(cols):
      transposed_rows[j][i] = sorted_rows[i][j]

  header = transposed_rows[0]
  multiple = {}
  for i in range(1,len(transposed_rows)):
    record = transposed_rows[i]
    if header_id != record[0]:
      header_id = record[0]
    else:
      multiple[header_id] = True
  for i in range(1,len(transposed_rows)):
      record = transposed_rows[i]
      if header_id != record[0]:
        header_count = 0
        header_id = record[0]
        if header_id in multiple:
          record[1] = 0
        else:
          record[1] = ''
      else:
        header_count += 1
        record[1] = header_count
      set_record(Dic, header, record)

  clean_list(Dic)

  dicJson = json.dumps(Dic)
  dicJson = re.sub('"Invoice"', '"{' + ns[''] + '}Invoice"', dicJson)
  dicJson = re.sub('xsi:', '{' + ns['xsi'] + '}', dicJson)
  dicJson = re.sub('cac:', '{' + ns['cac'] + '}', dicJson)
  dicJson = re.sub('cbc:', '{' + ns['cbc'] + '}', dicJson)
  dicJson = re.sub('qdt:', '{' + ns['qdt'] + '}', dicJson)
  dicJson = re.sub('udt:', '{' + ns['udt'] + '}', dicJson)
  dicJson = re.sub('ccts:', '{' + ns['ccts'] + '}', dicJson)
  dic2 = json.loads(dicJson)

  root = ET.XML('''
  <Invoice 
    xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2" 
    xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2" 
    xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2 http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/maindoc/UBL-Invoice-2.1.xsd" /> 
  ''')  # this step adds xsi:schemaLocation attribute

  tree = dict_to_etree(dic2, root)

  with open(out_file, 'wb') as f:
    t = ET.ElementTree(tree)
    t.write(f, encoding='UTF-8')

  if verbose:
    print(f'** END ** {out_file}')