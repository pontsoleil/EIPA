#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import xml.etree.ElementTree as ET
from collections import defaultdict
import csv
import re
import json
import sys 
import os
import argparse

from dic2etree import *

dictID = defaultdict(type(''))
dictXpath = defaultdict(type(''))

def file_path(pathname):
  if '/' == pathname[0:1]:
    return pathname
  else:
    dir = os.path.dirname(__file__)
    new_path = os.path.join(dir, pathname)
    return new_path

def dict_to_tsv(tsv, root):
  def _setup_record(case, path, tag, k, v):
    pathList = path.split('/')
    pathList.remove('')
    _path = ''
    base_id = ''
    bough_id = ''
    twig_id = ''
    for p in pathList:
      _path += '/'+p
      _id = dictID[_path]
      if 'ibg-' in _id:
        if _id and bough_id:
          twig_id = _id
        elif _id and base_id:
          bough_id = _id
        elif _id:
          base_id = _id
    _record = {}
    if 1 == case:
      pathString = path
      id = dictID[pathString]
      value = v
    elif 2 == case or 3 == case:
      pathString = path
      id = dictID[pathString]
      tag = k
      value = v
    elif 4 == case:
      pathString = path+'/'+k
      id = dictID[pathString]
      tag = k
      value = ''
    _record = {'case': case, 'base_id':base_id, 'bough_id':bough_id, 'twig_id':twig_id, 'id': id, \
                'path': pathString, 'tag': tag, 'value': value}
    return _record
  # def _to_tsv(tsv, d, tag, path):
  def _to_tsv(tsv, path, tag, body):
    if len(tag) > 0:
      path = path+'/'+tag
    d = body
    record = {}
    if not d:
      pass
    elif isinstance(d, str):  # case 1
      record = _setup_record(1, path, tag, '', d)
      tsv.append(record)
    elif isinstance(d, dict):
      for k, v in d.items():
        assert isinstance(k, str)
        if k.startswith('#'):
          assert k == '#text' and isinstance(v, str)  # case 2
          record = _setup_record(2, path, tag, k, v)
          tsv.append(record)
        elif isinstance(k, str) and k.startswith('@'):
          assert isinstance(v, str)  # case 3
          record = _setup_record(3, path, tag, k, v)
          tsv.append(record)
        elif isinstance(v, list):
          for e in v:  # case 4
            record = _setup_record(4, path, tag, k, e)
            tsv.append(record)
            tsv = _to_tsv(tsv, path, k, e)
        else:
          tsv = _to_tsv(tsv, path, k, v)
    else:
      assert d == 'invalid type', (type(d), d)
    return tsv
  assert isinstance(root, dict) and len(root) == 1
  for tag, body in root.items():
    tsv = _to_tsv(tsv, '', tag, body)
  return tsv

def main():
  # Create the parser
  parser = argparse.ArgumentParser(prog='invoice2tsv',
                                  usage='%(prog)s [options] infile outfile',
                                  description='電子インボイスXMLファイルをTSVファイルに変換')
  # Add the arguments
  parser.add_argument('inFile', metavar='infile', type=str, help='入力XMLファイル')
  parser.add_argument('outFile', metavar='outfile', type=str, help='出力ファイル')
  parser.add_argument('-v', '--verbose', action='store_true')
  args = parser.parse_args()
  in_file = file_path(args.inFile)
  out_file = file_path(args.outFile)
  verbose = args.verbose
  # Check if infile exists
  if not os.path.isfile(in_file):
    print('入力ファイルがありません')
    sys.exit()
  if verbose:
    print('** START ** ', __file__)

  dictID['/Invoice'] = 'ibg-00'

  xpath_file = file_path('data/common/xpath.txt')
  with open(xpath_file, encoding='utf-8', newline='') as f0:
    reader = csv.reader(f0, delimiter='\t')
    header = next(reader)
    for record in reader:
      id = record[1].strip()
      if id:
        xpath = record[9]
        if len(record) > 11 and '/' in xpath:
          level = record[2]
          BT = record[3]
          card = record[4].strip()
          datatype = record[5]
          section = record[6]
          extension = record[7]
          attributes = record[10]
          rules = record[11]
          data = {'level':level, 'BT':BT, 'card':card, 'datatype':datatype, 'section':section, \
                  'extension':extension, 'xpath':xpath, 'attributes':attributes, 'rules': rules}
          dictID[xpath] = id
          dictXpath[id] = data
          if 'Amount' == datatype or 'Unit' == datatype:
            level = str(int(level)+1)
            id = id+'-1'
            xpath = xpath+'/@currencyID'
            data = { 'level':level, 'BT':None, 'card':None, 'datatype':None, 'section':None, \
                     'extension':None, 'xpath':xpath, 'attributes':None, 'rules': None }
            if not dictID[xpath]:
              dictID[xpath] = id
              dictXpath[id] = data
          elif 'Quantity' == datatype:
            level = str(int(level)+1)
            id = id+'-1'
            xpath = xpath+'/@unitCode'
            data = { 'level':level, 'BT':None, 'card':None, 'datatype':None, 'section':None, \
                     'extension':None, 'xpath':xpath, 'attributes':None, 'rules': None }
            if not dictID[xpath]:
              dictID[xpath] = id
              dictXpath[id] = data

  tree = ET.parse(in_file)
  root = tree.getroot()
  dic = etree_to_dict(root)

  dicJson = json.dumps(dic)
  dicJson = re.sub('{' + ns[''] + '}', '', dicJson)
  dicJson = re.sub('{' + ns['cac'] + '}', 'cac:', dicJson)
  dicJson = re.sub('{' + ns['cbc'] + '}', 'cbc:', dicJson)
  dic2 = json.loads(dicJson)

  tsv = []
  tsv = dict_to_tsv(tsv, dic2)
  
  header = []
  column_header = []
  for record in tsv:
    case = record['case']
    id = record['id']+'_'+str(case)
    if 4 != case and id and not 'ibg-' in id and not id in header:
      header.append(id)
    base_id = record['base_id']
    bough_id = record['bough_id']
    twig_id = record['twig_id']
    column_id = base_id+'_'+bough_id+'_'+twig_id
    if not column_id in column_header:
      column_header.append(column_id)
  header.sort()
  column_header.sort()

  max_index = 0
  for record in tsv:
    case = record['case']
    id = record['id']
    if 4 != case and id and not 'ibg-' in id:
      index = header.index(id+'_'+str(case))
      if index > max_index:
        max_index = index

  with open(out_file, 'w') as f:
    writer = csv.writer(f, delimiter='\t')

    N = 7
    # N = 4 
    
    id = None
    prev_id = None

    column = [None] * (max_index + 1)
    for i in range(max_index + 1):
      id = header[i]
      if '-' == id[-2:-1]:
        if verbose:
          print('header %s has - in %s' % i, id)
      else:
        if prev_id and '_2' == prev_id[-2:] and '_3' == id[-2:] and prev_id[:-2] == id[:-2]:
          column[i] = id[:-2]+'-1'
        else:
          column[i] = id[:-2]
      prev_id = id
    writer.writerow([None] * N + column)

    column = [None] * (max_index + 1)
    for i in range(max_index + 1):
      id = header[i]
      if id and id[:-2] and id[:-2] in dictXpath and 'BT' in dictXpath[id[:-2]]:
        column[i] = dictXpath[id[:-2]]['BT']
      else:
        column[i] = ''
    writer.writerow([None] * N + column)

    column = [None] * (max_index + 1)
    for i in range(max_index + 1):
      id = header[i]
      if id and id[:-2] and id[:-2] in dictXpath and 'xpath' in dictXpath[id[:-2]]:
        column[i] = dictXpath[id[:-2]]['xpath']
      else:
        column[i] = ''
    writer.writerow([None] * N + column)

    column = [None] * (max_index + 1)
    current_id = None
    repetition = {}
    twigs = {}
    for record in tsv:
      column_id = record['base_id']+'_'+record['bough_id']+'_'+record['twig_id']
      if column != [None] * (max_index + 1) != column and \
          'ibg-00' != id and current_id and current_id != column_id:
        if bough_card:
          if '..1' == bough_card[1:]:
            bough_card = ''
          elif '..n' == bough_card[1:]:
            bough_card = 0
            if bough_id in repetition:
              bough_card = repetition[bough_id]
        if twig_card:
          if '..1' == twig_card[1:]:
            twig_card = ''
          elif '..n' == twig_card[1:]:
            twig_card = 0
            if twig_id in repetition:
              twig_card = repetition[twig_id]
            else:
              twig_card = 0
              repetition[twig_id] = 0
            # assuming bough_id is in repetition:
            if not bough_id in twigs:
              twigs[bough_id] = []
            if not twig_id in twigs[bough_id]:
              twigs[bough_id].append(twig_id)
        if verbose:
          print('* bough:'+bough_id, str(bough_card), 'twig:'+twig_id, str(twig_card))
        if bough_id:
          bough_name = dictXpath[bough_id]['BT']
        else:
          bough_name = ''
        if twig_id:
          twig_name = dictXpath[twig_id]['BT']
        else:
          twig_name = ''
        column_index = base_id+'_'+bough_id+'_'+str(bough_card)+'_'+twig_id+'_'+str(twig_card)
        writer.writerow([ bough_id, bough_card, twig_id, twig_card, column_index, bough_name, twig_name ] + column)
        column = [None] * (max_index + 1)
      case = record['case']
      id = record['id']
      base_id = record['base_id']
      bough_id = record['bough_id']
      twig_id = record['twig_id']
      # tag = record['tag']
      value = record['value'].encode('unicode_escape').decode('utf-8')
      # path = record['path']
      current_id = column_id
      if bough_id and dictXpath[bough_id] and dictXpath[bough_id]['card']:
        bough_card = dictXpath[bough_id]['card']
      else:
        bough_id = ''
        bough_card = ''
      if twig_id and dictXpath[twig_id] and dictXpath[twig_id]['card']:
        twig_card = dictXpath[twig_id]['card']
      else:
        twig_id = ''
        twig_card = ''
      
      if 4 != case and id and not 'ibg-' in id:
        index = header.index(id+'_'+str(case))
        column[index] = value
        
      if 4 == case:
        if not id in repetition:
          repetition[id] = 0
        else:
          repetition[id] += 1
          if id in twigs:
            twig_ids = twigs[id]
            if twig_ids:
              for i in twig_ids:
                repetition[i] = 0
      if verbose:
        print('  bough:'+bough_id, str(bough_card), 'twig:'+twig_id, str(twig_card), \
              'repetition:'+json.dumps(repetition), 'twigs:'+json.dumps(twigs))

if __name__ == '__main__':
    # execute only if run as a script
    main()