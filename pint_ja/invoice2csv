#!/usr/bin/env python3
#coding: utf-8
#
# generate CSV from Open Peoopl e-Invoice (UBL 2.1)
# 
# designed by SAMBUICHI, Nobuyuki (Sambuichi Professional Engineers Office)
# written by SAMBUICHI, Nobuyuki (Sambuichi Professional Engineers Office)
#
# MIT License
# 
# Copyright (c) 2021 SAMBUICHI Nobuyuki (Sambuichi Professional Engineers Office)
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
import xml.etree.ElementTree as ET
import csv
import re
import sys 
import os
import argparse
import collections

from dic2etree import *

DocumentCurrencyCode = ''
TaxCurrencyCode = ''
SupplierTaxScheme = ''
pintLst = []
pintDct = {}
pintSemSort = {}

boughLvl = 0
bough0 = {'level':boughLvl,'id':'ibg-00', 'count':''}
boughs = {}
boughs[0] = [bough0]

def file_path(pathname):
  if '/'==pathname[0:1]:
    return pathname
  else:
    dir = os.path.dirname(__file__)
    new_path = os.path.join(dir, pathname)
    return new_path

def formatXPath(xpath):
  xpath = re.sub(r'cac:','{'+ns['cac']+'}',xpath)
  xpath = re.sub(r'cbc:','{'+ns['cbc']+'}',xpath)
  if re.match(r'^.*/@[a-zA-Z]*$',xpath):
    path = re.sub(r'(.*)/@.*$','\\1',xpath)
    attr = re.sub(r'.*/@(.*)$','\\1',xpath)
    xpath = [path,attr]
  else:
    xpath = re.sub(r'false\(\)',"'false'",xpath)
    xpath = re.sub(r'true\(\)',"'true'",xpath)
  return xpath

def updateBough(n,i,count,boughLvl):
  data = pintLst[i]
  id = data['id']
  BT = data['BT']
  n = len(rows) - 1
  if id in L1multipleBG or n > 0:
    n = n + 1
  if len(boughs[n-1]) > boughLvl:
    _boughs = boughs[n-1][:boughLvl]
  else:
    _boughs = boughs[n-1]
  rows[n] = {'0000':id,'0001':BT}
  # if DEBUG: print(f'{getframeinfo(currentframe()).lineno}: n={n} i={i} - updateBough rows[{n}] {rows[n]["0001"]}({rows[n]["0000"]})[{count}]')
  boughs[n] = _boughs + [{'level':boughLvl,'id':id, 'count':count}]
  if DEBUG: print(f'{getframeinfo(currentframe()).lineno}: boughs[{n}] {boughs[n]}')
  return n

def fillData(parent,parentXPath,i,n,count):
  data = pintLst[i]
  semSort = data['semSort']
  id = data['id']
  level = data['level']
  BT = data['BT']
  xpath = data['xpath']
  if not xpath or len(xpath) < 9:
    return
  xpath = xpath[9:]
  xpath = formatXPath(xpath)
  text = None
  try:
    if isinstance(xpath,list):
      element = None
      if parentXPath:
        _xpath = xpath[0].replace(parentXPath+'/','')
      else:
        _xpath = xpath[0]
      element = parent.find(_xpath)
      if element and ET.iselement(element):
        if isinstance(xpath,list) and xpath[1]:
          attrib = xpath[1]
          if attrib and attrib in element.attrib:
            text = element.attrib[attrib]
        else:
          text = element.findtext('.')
    else:
      if parentXPath:
        _xpath = xpath.replace(parentXPath+'/','')
      else:
        _xpath = xpath
      text = parent.findtext(_xpath)
      if not text:
        text = root.findtext(_xpath)
  except SyntaxError:
    print (f'-- SyntaxError .//{xpath}')
  if text:
    if re.match(r'ibg-',id):
      text = ''
    # text = re.sub(r'[\s]*','',text)
    text = text.strip()
    rows[n][semSort] = {'id':id,'level':level,'BT':BT,'text':text}
    if DEBUG: print(f'{getframeinfo(currentframe()).lineno}: n={n} i={i} * {rows[n][semSort]}')
  return i + 1

def fillGroup(parent,parentPath,i,n,parentCount,boughLvl):
  boughLvl = len(boughs[n])
  data = pintLst[i]
  id = data['id']
  level = data['level']
  BT = data['BT']
  if id in L1singleBTG:
    n = 0
  if DEBUG: print(f'{getframeinfo(currentframe()).lineno}: n={n} i={i} - fillGroup {BT}({id}) boughLvl={boughLvl}')
  xpath = data['xpath']
  if not xpath or len(xpath) < 9:
    return
  while i < len(pintLst):
    xpath = xpath[9:]
    xpath = formatXPath(xpath)
    if parentPath:
      _xpath = re.sub(parentPath+'/', '', xpath)
    if re.match(r'ibt-',id):
      return None
    elif re.match(r'ibg-',id):
      elements = parent.findall(_xpath)
      _i = i
      next_i = None
      if not elements or 0==len(elements):
        count = ''
      elif len(elements) > 0:
        if len(elements) > 1:
          count = 0
          n = updateBough(n,i,count,boughLvl)
        else:
          count = ''
          n = len(rows) - 1
        for element in elements:
          _i = i + 1
          _data = pintLst[_i]
          _id = _data['id']
          _level = _data['level']
          _BT = _data['BT']
          # if DEBUG: print(f'{getframeinfo(currentframe()).lineno}: n={n} i={_i} - fillGroup try {BT}({id})[{count}] -> {_BT}({_id})')
          if isinstance(count,int) and count > 0 and count < len(elements):
            n = updateBough(n,i,count,boughLvl)
          while _level > level and _i < len(pintLst):
            current = None
            next_i = None
            if re.match(r'^ibg-',_id):
              current = fillGroup(element,xpath,_i,n,count,boughLvl)
              next_i = current['next_i']
              n = current['n']
            elif re.match(r'^ibt-',_id):
              next_i = fillData(element,xpath,_i,n,count)
            if next_i:
              if next_i < len(pintLst):
                next_data = pintLst[next_i]
                _id = next_data['id']
                _level = next_data['level']
                _i = next_i
              if next_i == len(pintLst):
                _i = next_i
            else:
              _i += 1
          if isinstance(count,int):
            count += 1
      if next_i:
        i = next_i
        next_i = None
      else:
        i = _i + 1
    return {'n':n,'next_i':i}

if __name__=='__main__':
  # Create the parser
  parser = argparse.ArgumentParser(prog='invoice2csv',
                                    usage='%(prog)s [options] infile -o outfile',
                                    description='電子インボイスXMLファイルをSVファイルに変換')
  # Add the arguments
  parser.add_argument('inFile', metavar='infile', type=str, help='入力XMLファイル')
  parser.add_argument('-o', '--outfile')
  parser.add_argument('-e', '--encoding')  # 'Shift_JIS' 'cp932'
  parser.add_argument('-v', '--verbose', action='store_true')
  parser.add_argument('-d', '--debug', action='store_true')

  args = parser.parse_args()
  in_file = file_path(args.inFile)
  pre, ext = os.path.splitext(in_file)
  tmp_file = pre+'.txt'
  if args.outfile:
    out_file = args.outfile.lstrip()
    out_file = file_path(out_file)
  else:
    out_file = pre+'.csv'
  ncdng = args.encoding
  if ncdng:
    ncdng = ncdng.lstrip()
  else:
    ncdng = 'UTF-8'
  verbose = args.verbose
  DEBUG = args.debug
  if DEBUG:
    from inspect import currentframe, getframeinfo

  # Check if infile exists
  if not os.path.isfile(in_file):
    print('入力ファイルがありません')
    sys.exit()
  if verbose:
    print(f'** START ** {__file__}')

  if verbose:
    print(f'*** Input file {in_file}')
  tree = ET.parse(in_file)
  root = tree.getroot()

  DocumentCurrencyCode = root.findtext(".//{"+ns['cbc']+"}DocumentCurrencyCode")
  TaxCurrencyCode = root.findtext(".//{"+ns['cbc']+"}TaxCurrencyCode")
  SupplierTaxScheme = root.findtext(".//{"+ns['cac']+"}AccountingSupplierParty/"+
    "{"+ns['cac']+"}Party/{"+ns['cac']+"}PartyTaxScheme/{"+ns['cac']+"}TaxScheme/{"+ns['cbc']+"}ID")

  pint_file = file_path('data/common/xpath.csv')
  # SemSort,BT_ID,ID,Level,BT,BT_ja,Definition,Definition_ja,Explanation,Explanation_ja,Example,
  # 0       1     2  3     4  5     6          7             8           9              10      
  # Card,DataType,Section,Extension,SyntSort,XPath,Attributes,Rules,UBL_DataType,Cardinality,Alignment
  # 11   12       13      14        15       16    17         18    19           20          21
  COL_SemanticSort = 0
  COL_ID = 2
  COL_level = 3
  COL_BT = 4
  COL_BT_ja = 5
  COL_card = 11
  COL_datatype = 12
  COL_SyntaxSort = 15
  COL_xpath = 16
  if verbose: print(f'*** XPath file {pint_file}')
  with open(pint_file, encoding='utf-8', newline='') as f0:
    reader = csv.reader(f0) #, delimiter='\t')
    header = next(reader)
    for v in reader:
      id = v[COL_ID].strip()
      if id:
        if 'VAT'==SupplierTaxScheme:
          if 'ibt-032'==id:
            continue
        else:
          if 'ibt-031'==id:
            continue
        xpath = v[COL_xpath]
        syntaxSort = v[COL_SyntaxSort]
        if not syntaxSort:
          syntaxSort = '9999'
        if not xpath:
          xpath = '/'+id
        if len(v) > COL_xpath and '/' in xpath:
          if '/Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID=/Invoice/cbc:DocumentCurrencyCode/text()]'==xpath:
            xpath = '/Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID="'+DocumentCurrencyCode+'"]'
          elif '/Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID=/Invoice/cbc:TaxCurrencyCode/text()]'==xpath:
            if TaxCurrencyCode:
              xpath = '/Invoice/cac:TaxTotal/cbc:TaxAmount[@currencyID="'+TaxCurrencyCode+'"]'
            else:
              continue
          elif "[not(cbc:DocumentTypeCode='130')]" in xpath:
            xpath = xpath.replace("[not(cbc:DocumentTypeCode='130')]",'')
          elif "[cbc:DocumentTypeCode='130']" in xpath:
            xpath = xpath.replace("[cbc:DocumentTypeCode='130']",'')
          semanticSort = v[COL_SemanticSort]
          if v[COL_BT]: BT = v[COL_BT]
          else: BT = None
          if v[COL_BT_ja]: BT_ja = v[COL_BT_ja]
          else: BT_ja = None
          level = v[COL_level]
          card = ''+v[COL_card].strip()
          datatype = ''+v[COL_datatype].strip()
          data = {'semSort':semanticSort,'id':id,'level':level,'BT':BT,'BT_ja':BT_ja,'card':card,'datatype':datatype,'xpath':xpath}
          pintLst.append(data)
          pintDct[semanticSort] = data
          pintSemSort[id] = semanticSort

  idxLevel = {}
  idxLevel[0] = []
  parents = {}
  for i in range(len(pintLst)):
    data = pintLst[i]
    level = int(data['level'])
    id = data['id']
    num = id
    if level > 0:
      num =  [id] + idxLevel[level - 1]
    idxLevel[level] = num
    parents[id] = num

  L1singleBTG = [x['id'] for x in pintLst if '1'==x['level'] and '1'==x['card'][3:]]
  L1multipleBG = [x['id'] for x in pintLst if '1'==x['level'] and re.match(r'ibg-', x['id']) and 'n'==x['card'][3:]]

  # https://www.geeksforgeeks.org/ways-sort-list-dictionaries-values-python-using-itemgetter/ 
  # https://www.delftstack.com/ja/howto/python/sort-list-of-lists-in-python/
  sorted_rows = sorted(pintLst, key=lambda x:x['semSort'])
  pintLst = sorted_rows

  n = 0
  rows = {}
  rows[0] = {'0000':'ibg-00','0001':'CONTENT'}
  parent_xpath = None
  count = ''
  i = 0
  next_i = None
  boughLvl = 1
  while i < len(pintLst):
    data = pintLst[i]
    semSort = data['semSort']
    id = data['id']
    BT = data['BT']
    level = data['level']
    xpath = data['xpath']
    # if DEBUG: print(f'{getframeinfo(currentframe()).lineno}: n={n} pintLst[{i}] {BT}({id})')
    xpath = xpath[9:]
    xpath = formatXPath(xpath)
    if re.match(r'^ibt-',id):
      i = fillData(root,'',i,n,None)
    elif re.match(r'^ibg-',id):
      if id in L1singleBTG:
        n = 0
      elements = root.findall(xpath)
      _i = i
      if not elements or 0==len(elements):
        count = ''
      elif len(elements) > 0:
        if len(elements) > 1:
          count = 0
          n = updateBough(n,i,count,boughLvl)
        else:
          count = ''
        for element in elements:
          _i = i + 1
          _data = pintLst[_i]
          _id = _data['id']
          _level = _data['level']
          _BT = _data['BT']
          # if DEBUG: print(f'{getframeinfo(currentframe()).lineno}: n={n} _i={_i} try {BT}({id})[{count}] -> {_BT}({_id})')
          if isinstance(count,int) and count > 0 and count < len(elements):
            n = updateBough(n,i,count,boughLvl)
          while _level > level and _i < len(pintLst):
            _data = pintLst[_i]
            _id = _data['id']
            _level = _data['level']
            _BT = _data['BT']
            # if DEBUG: print(f'{getframeinfo(currentframe()).lineno}: n={n} i={_i} try {BT}({id})[{count}] -> {_BT}({_id})')
            current = None
            next_i = None
            if re.match(r'^ibg-',_id):
              current = fillGroup(element,xpath,_i,n,count,boughLvl)
              next_i = current['next_i']
              n = current['n']
            else:
              next_i = fillData(element,xpath,_i,n,count)
            if next_i:
              if next_i < len(pintLst):
                next_data = pintLst[next_i]
                _level = next_data['level']
                _i = next_i
              elif next_i == len(pintLst):
                _i = next_i
            else:
              _i += 1
          if isinstance(count,int):
            count += 1
      if next_i:
        i = next_i
        next_i = None
      else:
        i = _i + 1

  checkedParents = []
  for id in rows[0].keys():
    if re.match(r'^ibg-',id):
      if not id in checkedParents:
        checkedParents.append(id)

  checkedData = []
  for k,v in rows.items():
    for semanticSort,data in v.items():
      if semanticSort < '1000': continue
      id = data['id']
      parentIDs = parents[id][1:]
      for parentID in parentIDs:
        if re.match(r'ibg-',parentID) and not parentID in checkedData and not parentID in checkedParents:
          semanticSort = pintSemSort[parentID]
          data = {'id':parentID, 'semanticSort':semanticSort}
          if not data in checkedData:
            checkedData.append(data)

  for parent in checkedData:
    id = parent['id']
    semanticSort = parent['semanticSort']
    data = pintDct[semanticSort]
    if not semanticSort in rows[0].keys():
      rows[0][semanticSort] = {'id':data['id'],'level':data['level'],'BT':data['BT'],'text':''}

  maxBoughLvl = 1
  for n,data in boughs.items():
    for bough in data:
      level = int(bough['level'])
      if level > maxBoughLvl:
        maxBoughLvl = level

  bough_rows = {}
  for n in rows.keys():
    bough_rows[n] = {}
    for bough in boughs[n]:
      level = int(bough['level'])
      id = bough['id']
      if 'ibg-00'==id:
        BT = 'INVOICE'
      else:
        semSort = pintSemSort[id]
        data = pintDct[semSort]
        BT = data['BT']
      count = str(bough['count'])
      bough_rows[n]['000'+str(3*level)] = id
      bough_rows[n]['000'+str(1+3*level)] = BT
      bough_rows[n]['000'+str(2+3*level)] = count

  for n,row in rows.items():
    for semSort,data in row.items():
      if int(semSort) < 1000:
        continue
      bough_rows[n][semSort] = data

  max_col = len(bough_rows)
  transposed = {}
  lookup = {}
  index = 0
  for col,row in bough_rows.items():
    for semSort,data in row.items():
      if not semSort in transposed:
        transposed[semSort] = {}
        if semSort in pintDct:
          d = pintDct[semSort]
          transposed[semSort][0] = d['id']
          transposed[semSort][1] = d['level']
          transposed[semSort][2] = d['card']
          transposed[semSort][3] = d['BT']
        else:
          transposed[semSort][0] = ''
          transposed[semSort][1] = ''
          transposed[semSort][2] = ''
          transposed[semSort][3] = ''
      if int(semSort) < 1000: # '0000'==semSort or '0001'==semSort:
        transposed[semSort][4+col] = data
      elif data['text']:
        transposed[semSort][4+col] = data['text']

  od_transposed = collections.OrderedDict(sorted(transposed.items()))
    
  del_list = []
  for semSort,data in od_transposed.items():
    check = ''
    for k,v in data.items():
      if k > 3:
        check += v
    if not check and not re.match(r'^ibg-',data[0]):
      del_list.append(semSort)

  for semSort in del_list:
    del transposed[semSort]

  max_col += 4
  lst = []
  i = 0
  for row in od_transposed:
    lst.append(['']*max_col)

  i = 0
  for semSort,data in od_transposed.items():
    for j in range(max_col):
      if j in od_transposed[semSort]:
        lst[i][j] = od_transposed[semSort][j]
    i += 1

  with open(out_file, 'w', encoding=ncdng) as f:
    writer = csv.writer(f)#, delimiter='\t')
    n = 0
    for l in lst:
      if n < 3:
        n += 1
        continue
      writer.writerow(l)

  if verbose:
    print(f'** END ** {out_file}')